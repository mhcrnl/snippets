The Linux kernel virtual address space (on a 32-bit systems such as x86_32) is 1GB wide, starting from `PAGE_OFFSET` (usually `0xc0000000`). The lower part of the the physical memory (dubbed _low-mem_), starting from physical address `0` to a physical address (usually `896MB`) is linearly mapped in the first part (usually `896MB`) of the Linux kernel virtual address space. That is all kernel space-specific page tables are filled with this mapping; i.e. an access from kernel space to virtual address `PAGE_OFFSET + 50MB` will pass through MMU/TLB/page tables and result in acccessing the physical address `50MB`. The kernel, as the ruler of the system, may write/read to any address; if it does something nasty, well, you can't stop it, it's the kernel. So be careful when coding it :-P

This direct mapping of the _low-mem_ has the benefit of being able to directly extract the physical address when you know the virtual address in the kernel virtual address space and viceversa. This is not happenning when actually accessing data from there; when you do that the MMU/TLB/page tables come into play. However, there are moments when you simply want a translation of a virtual address into a physical address and viceversa. For that explicit translation action, there is no need to go through a rather expensive walk through the kernel space-specific page tables. You can do a simple arithmetic since `physical_address = virtual_adress - PAGE_OFFSET` for physical addresses in _low-mem_.

This kernel module (`kernel-page-table-walk.c`) does two walks:

    # When the module is inserted, it walks through pages from `PAGE_OFFSET` to `high_memory` (the end of the _low-mem_ mapping in the kernel virtual address space and the start of the _high-memory_ mapping).
    # When the module is removed, it walks through pages from `high_memory` to `VMALLOC_START`. This area is a "hole" in the kernel virtual address space that is used to catch out-out-bounds accesses in the _low-mem_ mapping. Check [the source code](http://lxr.free-electrons.com/source/arch/x86/include/asm/pgtable_32_types.h?v=3.13#L20) for more information.

Each walk reads the first byte of each page and does a dumb exclusive or operation to it. The first walk is successful, going through `low_mem_sieze / PAGE_SIZE` pages. It will be successful and print out the number of pages walked. The second walk (when removing the module) will end in an oops, since we will access the "hole" in the kernel virtual address space, an invalid virtual area.
